## 🚀 프로젝트 소개
> 이번 주차는 블랙잭 게임을 구현한다.
>
<br>

### 1. 게임 진행 및 규칙

<details>
    <summary>게임 규칙</summary>
    <div markdown="1">

**개요**

- 블랙잭 게임은 딜러와 플레이어 중 카드의 합이 21 또는 21에 가장 가까운 숫자를 가지는 쪽이 이기는 게임이다.

 
- 카드의 숫자 계산은 카드 숫자를 기본으로 한다.


- 예외로 Ace는 1 또는 11로 계산할 수 있다.


- King, Queen, Jack은 각각 10으로 계산한다.


**게임 결과 산출**

- 처음 두 장의 카드 합이 21일 경우 블랙잭이 되며, 배팅 금액의 1.5배를 딜러에게 받는다. 단, 딜러와 플레이어가 모두 동시에 블랙잭인 경우, 플레이어는 배팅한 금액을 돌려받는다.


- 플레이어가 가진 모든 카드의 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만들면 이긴다.


- 딜러가 21을 초과하면 그 시점까지 남아있던 플레이어들은 가지고 있는 패에 상관 없이 승리해 배팅 금액을 받는다.

<br>
</div>
</details>

<details>
    <summary>part 1. 플레이어</summary>
    <div markdown="1">

- 플레이어는 게임을 시작할 때 배팅 금액을 정해야 한다.

- 게임을 시작하면 플레이어는 두 장의 카드를 지급받으며, 두 장의 카드 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만든다.

- 21을 넘지 않을 경우 원한다면 얼마든지 카드를 계속 뽑을 수 있다. 단, 카드를 추가로 뽑아 21을 초과할 경우 배팅 금액을 모두 잃게 된다.

<br>
</div>
</details>

<details>
    <summary>part 2. 딜러</summary>
    <div markdown="1">

- 딜러는 처음에 받은 2장의 합계가 16 이하이면 반드시 1장의 카드를 추가로 받고, 17점 이상이면 추가로 받지 않는다.


<br>
</div>
</details>

<br>

### 2. 입출력 요구 사항

<details>
    <summary>실행 결과 예시</summary>
    <div markdown="1">

```
게임에 참여할 사람의 이름을 입력하세요.(쉼표 기준으로 분리)
pobi, jason

pobi의 배팅 금액은?
10000

jason의 배팅 금액은?
20000

딜러와 pobi, jason에게 2장씩 나누었습니다.
딜러: 3다이아몬드, 9클로버
pobi카드: 2하트, 8스페이드
jason카드: 7클로버, K스페이드

pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
y
pobi카드: 2하트, 8스페이드, A클로버
pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
n

jason은 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
n
jason카드: 7클로버, K스페이드

딜러는 16이하라 한장의 카드를 더 받았습니다.

딜러카드: 3다이아몬드, 9클로버, 8다이아몬드 - 결과: 20
pobi카드: 2하트, 8스페이드, A클로버 - 결과: 21
jason카드: 7클로버, K스페이드 - 결과: 17

## 최종 수익
딜러: 10000
pobi: 10000
jason: -20000
```

<br>
</div>
</details>

<br>


### 3. 과제 요구 조건

주어진 `Card`, `CardFactory`, `Symbol`, `Type`, `Dealer`, `Player` 클래스를 활용하여 구현한다.


<br><br>

## 📝 구현할 기능 목록

### 게임 시작

- [x] `입력 UI` : 참여할 사람들의 이름을 쉼표 기준으로 입력 받기
    - [x] `exception` : 입력된 값을 문자열로 변환할 수 없을 경우
    - [x] `exception` : 입력된 값이 공백일 경우
    - [x] `exception` : 쉼표 기준으로 구분된 값들이 공백일 경우
    - [x] 예외 발생시, `출력 UI` : 에러메시지 출력
    - [x] 예외 발생시, 정상적인 입력을 받을 때까지 다시 윗 단계 반복


- [x] `입력 UI` : 각 플레이어의 배팅 금액 입력 받기
    - [x] `exception` : 0 이하의 금액을 입력하였을 경우
    - [x] 예외 발생시, `출력 UI` : 에러메시지 출력
    - [x] 예외 발생시, 정상적인 입력을 받을 때까지 다시 윗 단계 반복


- [x] 플레이어들 생성하기
- [x] 딜러 생성하기


- [x] 딜러가 카드를 섞기


- [x] 딜러와 각 플레이어들의 카드를 CardFactory와 Card를 통해 중복되지 않게 랜덤으로 나누어주기


- [x] `출력 UI` : 각 플레이어에게 2장씩 나누어주었다는 문구 출력
- [x] `출력 UI` : 딜러와 플레이어들에게 배분된 카드 출력하기


### 게임 진행

- [x] 블랙잭 찾기 : 두 장의 카드를 합쳐 21이 되는 플레이어나 딜러 찾기
  - [x] Ace가 있는 경우, 1이 아니라 11로 계산하는 것이 더욱 21에 가깝다면 11로 계산하기
  - 블랙잭이 있는 경우, 게임 종료 및 수익 계산하기
    - [x] `출력 UI` : 최종 게임 결과 출력하기
    - [x] 모든 플레이어의 최종 수익 계산하기
      - [x] 만약 플레이어만 블랙잭인 경우, 플레이어가 배팅 금액의 1.5배를 딜러에게 받는다.
      - [x] 만약 딜러와 플레이어가 동시에 블랙잭인 경우, 플레이어는 배팅한 금액만 돌려받는다.
      - [x] 딜러가 블랙잭인 경우, 플레이어들은 배팅한 금액을 돌려받지 못한다.
    - [x] `출력 UI` : 최종 수익 출력하기


- [x] 두 장의 카드를 합쳐 21을 초과하지 않는 플레이어들을 도출하기
  - [x] Ace가 있는 경우, 1로 계산 혹은 11로 계산한 경우를 모두 따지기


- [x] `입력 UI` : 위 단계에서 도출한 플레이어들이 있다면, 해당 플레이어들 중 한 명에게 카드를 더 받을지 여부 입력받기
  - [x] y일 경우, 해당 플레이어에게 새로운 카드를 중복되지 않게 랜덤으로 배분
  - [x] `출력 UI` : 해당 플레이어에게 배분된 카드 목록을 갱신하여 출력하기
  - [x] 만약 플레이어의 카드 합이 21이 아직 안 되었을 경우, 위의 과정 반복하기
  - [x] `exception` : y, n 이외의 값을 입력받을 경우


- [x] 딜러의 카드 숫자 합이 16 이하인지 아닌지 판별하기
    - 딜러의 카드 숫자 합이 16 이하일 경우
      - [x] `출력 UI` : 딜러가 카드를 받았다는 문구 출력하기
      - [x] 딜러에게 새로운 카드를 지금까지 나온 카드와 중복되지 않게 배분
        - [x] 만약 딜러의 카드 수의 합이 21을 초과하면, 현재 남아있는 플레이어들은 모두 이긴 것으로 처리된다.
    - 딜러의 카드 숫자 합이 17 이상일 경우
      - [x] `출력 UI` : 딜러가 카드를 받지 않았다는 문구 출력


### 게임 결과 산출

- [x] 카드 더 받기가 끝나면, 모든 플레이어와 딜러의 카드 합을 계산한다.


- [x] `출력 UI` : 딜러의 카드 숫자 합 출력하기
- [x] `출력 UI` : 각 플레이어의 카드 숫자 합 출력하기


- [x] 게임 결과에 따른 배팅 수익 계산하기
  - [x] 21을 넘지 않되 가장 21에 가까운 사람은 배팅한 금액이 수익이 된다.
  - [x] 진 플레이어는 배팅 금액을 잃는다.
  - [x] 딜러는 남은 배팅금액을 수익으로 한다.


- [x] `출력 UI` : 딜러의 수익 출력하기
- [x] `출력 UI` : 각 플레이어의 수익 출력하기


<br><br>

## 🔥 준수할 코드 컨벤션 목록


### Clean Code

- [ ] 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
  - `main()` 함수에도 적용된다.
  - 공백 라인도 한 라인에 해당한다.


- [ ] 함수(또는 메서드)가 한 가지 일만 잘하도록 구현한다.


- [x] 메서드의 파라미터 개수는 최대 3개까지만 허용한다.


- [x] indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.


- [X] 네이밍에 고민을 담는다. 특히 불용어를 사용하지 않고, 의도를 담되 가능한 한 명확하고 간결하게 하려고 노력한다.


- [x] 연관성이 있는 상수는 static final 대신 enum을 활용한다.


- [x] 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다. 객체의 복잡도를 낮추고, 버그 발생 가능성을 낮출 수 있다.
  - 필드에 중복이 있거나, 불필요한 필드가 없는지 확인해 필드의 수를 최소화한다.


<br>

### 객체 지향 프로그래밍 (OOP)
- [x] 객체의 상태 접근을 제한한다.
  - 인스턴스 변수의 접근 제어자는 private으로 구현한다.


- [x] 객체는 객체스럽게 사용한다.
  - 객체는 로직에 대한 구현을 통해 객체스럽게 사용하는 것이 중요하다.
  - 객체에서 데이터를 꺼내지(get) 말고 메시지를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다.


- [x] 비즈니스 로직과 UI 로직을 분리한다. 이는 단일 책임 원칙에 대한 것이다.
  - 현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 `toString()`을 통해 구현한다.
  - `View`에서 사용할 데이터라면 `getter` 메서드를 통해 데이터를 전달한다.
  - 즉, domain 패키지의 클래스에서 `InputView`, `OutputView` 를 사용하지 않는다.


- [x] `final` 키워드를 사용해 값의 변경을 막는다.
  - 최근에 등장하는 프로그래밍 언어들은 기본이 불변 값이다. 자바는 final 키워드를 활용해 값의 변경을 막을 수 있다.

<br>

### TDD
- [ ] JUnit 5와 AssertJ를 이용하여 본인이 정리한 기능 목록이 모두 정상 동작함을 테스트 코드로 확인한다.


- [ ] 발생할 수 있는 예외 상황을 모두 고려하여 구현하고, 테스트코드로 예외처리를 검증한다.
  - [ ] 특히, 경곗값에 대한 테스트를 꼼꼼하게 한다.


- [ ] 테스트 코드도 리팩토링을 통해 개선해본다.
  - [ ] 반복적인 코드를 중복되지 않게 만들도록 한다.


- [ ] 테스트를 위한 코드는 구현 코드에서 분리시킨다.
  - [ ] 테스트를 위해 접근 제어자를 바꾸지 않는다.
  - [ ] 테스트 코드에서만 사용되는 메서드는 구현 코드에 포함시키지 않는다.


- [ ] 단위 테스트하기 어려운 코드를 단위테스트하는 데에 도전해본다.
  - 리팩토링을 통해 테스트하기 어려운 것을 클래스 내부가 아닌 클래스 외부로 분리해본다.
  - 단위 테스트를 하기 어려운 부분은 분리하여 테스트 가능한 부분만 단위 테스트한다. 테스트하기 어려운 부분은 우선 단위테스트 하지 않는다.


- [ ] private 함수를 테스트하고 싶다면 클래스 분리를 해본다.
  - 오로지 가독성의 이유만으로 분리된 경우라면, public 함수가 private 함수를 사용하고 있기 때문에 자연스럽게 테스트 범위에 포함된다.
  - 하지만 가독성 이상의 역할을 하는 경우, 테스트하기 쉽게 구현하기 위해서는 해당 역할을 수행하는 다른 객체를 만드는 것을 고려해봄직하다.


<br>

### MVC 패턴
- [x] Model은 Controller와 View에 의존하지 않아야 한다.
    - 오직 데이터값만 다룬다.
    - `Model` 내부에 `controller`와 `view`에 관련된 코드가 있으면 안된다. 즉, `controller`와 `view`의 클래스를 import 해서 사용하면 안된다.


- [x] View는 model에만 의존해야 하고, Controller에는 의존하면 안 된다.
    - `view` 내부에 `model`의 코드만 있을 수 있고, `controller`의 코드가 있으면 안된다.


- [x] View가 Model로부터 데이터를 받을 때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 한다.
    - 사용자에게 보여주는 UI중 사용자 데이터 가져와야 되는 부분만 model에서 가져온다.
    - 즉, 모든 사용자에게 똑같이 보여주는 UI는 상수나 enum값을 활용하여 보여준다.


- [x] Controller는 Model과 View에 의존해도 된다.
    - Controller가 model과 view의 중재자 역할을 하며 전체 로직을 구성하기 때문이다.
    - 따라서, Controller 내부에는 model, view와 관련된 코드가 있을 수 있다.


- [x] View가 Model로부터 데이터를 받을 때, 반드시 Controller에서 받아야 한다.